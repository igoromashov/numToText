// Данная функция конвертирует число в текст.
// Используется как скрипт для Google Sheets для формирования счетов на оплату.
// Слово "класс" во всех комментариях обозначает класс числа (не класс JS).

function numToText(num) {
  // функция выдачи валюты в необходимом падеже без указания количества
  // корректность работы обеспечена только в рамках функции numToText
  // т.к. обеспечена передача в функцию только валидных данных
  const currency = (lastDigit) => {
    if (lastDigit.length === 2) {
      if (lastDigit[0] === "1") {
        return "рублей";
      } else {
        return currency(lastDigit.slice(1, 2));
      }
    } else {
      // от 0 до 9
      lastDigit = Number(lastDigit);
      if (lastDigit === 0 || lastDigit > 4) {
        return "рублей";
      } else if (lastDigit === 1) {
        return "рубль";
      } else if (lastDigit > 1 && lastDigit <= 4) {
        return "рубля";
      }
    }
  };

  // функция выдачи копеек в необходимом падеже с указанием количества
  // корректность работы обеспечена только в рамках функции numToText
  // т.к. обеспечена передача в функцию только валидных данных
  const pennies = (fraction) => {
    const lastDigit =
      Number(fraction) > 20
        ? Number(String(fraction).slice(1, 2))
        : Number(fraction);
    if (lastDigit < 20) {
      if (lastDigit === 0 || lastDigit > 4) {
        return fraction + " копеек";
      } else if (lastDigit === 1) {
        return fraction + " копейка";
      } else if (lastDigit > 1 && lastDigit <= 4) {
        return fraction + " копейки";
      }
    }
  };

  // КАРТЫ НАИМЕНОВАНИЙ
  // (для рубля => в мужском роде)

  // карта наименования единиц
  const units = {
    0: "",
    1: "один",
    2: "два",
    3: "три",
    4: "четыре",
    5: "пять",
    6: "шесть",
    7: "семь",
    8: "восемь",
    9: "девять",
  };

  // карта наименования чисел первого десятка
  const elevens = {
    1: "одиннадцать",
    2: "двенадцать",
    3: "тринадцать",
    4: "четырнадцать",
    5: "пятнадцать",
    6: "шестнадцать",
    7: "семнадцать",
    8: "восемнадцать",
    9: "девятнадцать",
  };

  // карта наименования количества десятков
  // полное наименование формируется путем конкатенации с именем единиц (units)
  const tens = {
    1: "десять",
    2: "двадцать",
    3: "тридцать",
    4: "сорок",
    5: "пятьдесят",
    6: "шестьдесят",
    7: "семьдесят",
    8: "восемьдесят",
    9: "девяносто",
  };

  // карта наименований количества сотен
  const hundreds = {
    1: "сто",
    2: "двести",
    3: "триста",
    4: "четыреста",
    5: "пятьсот",
    6: "шестьсот",
    7: "семьсот",
    8: "восемьсот",
    9: "девятьсот",
  };

  // карта наименований количества тысяч
  const thousands = {
    1: "одна",
    2: "две",
    3: "три",
    4: units[4],
    5: units[5],
    6: units[6],
    7: units[7],
    8: units[8],
    9: units[9],
  };

  // карта имён степеней тысячи (классов)
  // структура: mapDegree[k][n],
  // т.е. n * 1000 ** k,
  // где n - количественный множитель;
  // k - степень тысячи
  const mapDegree = {
    // k = 1 - тысячи
    1: {
      1: "тысяча",
      2: "тысячи",
      3: "тысячи",
      4: "тысячи",
      5: "тысяч",
      6: "тысяч",
      7: "тысяч",
      8: "тысяч",
      9: "тысяч",
    },
    // k = 2 - миллионы
    2: {
      1: "миллион",
      2: "миллиона",
      3: "миллиона",
      4: "миллиона",
      5: "миллионов",
      6: "миллионов",
      7: "миллионов",
      8: "миллионов",
      9: "миллионов",
    },
    // k = 3 - миллиарды
    3: {
      1: "миллиард",
      2: "миллиарда",
      3: "миллиарда",
      4: "миллиарда",
      5: "миллиардов",
      6: "миллиардов",
      7: "миллиардов",
      8: "миллиардов",
      9: "миллиардов",
    },
    // k = 4 - триллионы
    4: {
      1: "триллион",
      2: "триллиона",
      3: "триллиона",
      4: "триллиона",
      5: "триллионов",
      6: "триллионов",
      7: "триллионов",
      8: "триллионов",
      9: "триллионов",
    },
  };

  // карта ошибок
  const errors = {
    1: "ОШИБКА: введены невалидные данные",
    2: "ОШИБКА: слишком большое число"
  }

  let fixedNum;

  // если получен массив, в любом случае он конвертируется в строку
  if (Array.isArray(num)) {
    num = num.join("");
  }

  // если получена строка, удаляем все пробелы (если обнаружены)
  // также запятая заменяется на точку (если обнаружена)
  // утсанавливаем предельное принимаемое значение 9999999999999.99 (9 триллионов...)
  // в итоге проихводится конвертация полученного числа в строку (например 100.00)
  if (typeof num === "string") {
    fixedNum = Number(num.replace(/\s+/g,'').replace(/,/, ".")).toFixed(2).toString();
    if (fixedNum === "NaN") { //если Number не может собрать число из строки, он вернёт NaN, далее он превратится в "NaN"
      return errors[1];
    }
  } else if (typeof num === "number") {
    fixedNum = num.toFixed(2).toString();
  } else {
    return errors[1];
  }

  // проверка не превышено ли максимально обрабатываемое число
  // уже, в любом случае num === "string", но приведение видов в помощь...
  if (num > 9999999999999.99) {
    return errors[2];
  }

  // отделение целой части (все цифры до дробного разделителя)
  const integer = fixedNum.slice(0, fixedNum.length - 3);
  // отделение дробной части (все цифры после дробного разделителя)
  const fraction = fixedNum.slice(fixedNum.length - 2, fixedNum.length);
  
  // проверяем есть ли целая часть (рубли)
  // если нет, возвращаем копейки
  if (integer == 0) {
    return pennies(fraction);
  }

  const textInteger = []; // массив, состоящий из слов, составляющих полное наименование целой части числа
  const textCurrency = currency(integer.slice(integer.length - 2, integer.length)); // имя валюты по двум последним цифрам числа

  // функция формирования имени класса имён чисел класса
  // далее функцию вызываем в цикле
  // аргументы: предпредпоследнее число (Х..), предпоследнее число (.Х.), текущее число (..Х), степень тысячи
  const degreeName = (prePrevious, previous, current, hundredDegree) => {
    const res = [];   // создаётся результирующий массив
    let name = null;  // создаётся имя класса

    if (previous !== 1) { // исключаем числа *1* (*10-*19)
      if (!!current) { // обработка единиц (**Х)
        res.unshift(hundredDegree === 1 ? thousands[current] : units[current]);  // к тысячам особый подход, т.к. "тысяча" - женского рода
        name = !!hundredDegree ? mapDegree[hundredDegree][current] : null; // если степень тысячи больше 0 формируется имя класса по единице (**Х)
      }
      if (!!previous) { // обработка десятков *Х*
        res.unshift(tens[previous]);
      }
    } else {  // обработка чисел *1* (*10-*19)
      res.unshift(!!current ? elevens[current] : tens[previous]); // проверка на число *10
    }
    if (!!prePrevious) { // обработка сотен Х**
      res.unshift(hundreds[prePrevious]);
    }

    // формирование имени класса
    // если степень тысячи больше 0 и нет имени и класс не нулевой (000)
    // тогда назначаем имя класса в родительном падеже мн. числе (соотвествует кол-ву >= 5)
    // иначе назначаем ранее присвоенное (или нет) имя (имя по единице или null)
    name =
      !!hundredDegree && !name && (!!prePrevious || !!previous || !!current)
        ? mapDegree[hundredDegree][5] 
        : name;

    // если имя есть (не null), тогда записываем его в конец результирующего массива
    if (!!name) {
      res.push(name);
    }
    return res; // возвращаем результирующий массив
  };

  // циклом проходим по строке справа налево с шагом 3,
  // иммитируя проход по классам многозначного числа начиная с первого класса.
  // указатель current указывает на последнюю (правую) цифру класса.
  // hundredDegree - степень тысячи, вычисляется в процессе работы цикла,
  // используется для назначения имени степени тысячи в правилном падеже
  // nullClass - маркер нулевого класса (класс состоит из нулей - 000)

  for (let i = integer.length - 1, hundredDegree = 0; i >= 0; i = i - 3) {
    const current = Number(integer[i]);
    const previous = Number(integer[i - 1]);
    const prePrevious = Number(integer[i - 2]);
    // записываем элементы результирующего массива res из функции degreeName в массив полного имени числа
    textInteger.unshift(...degreeName(prePrevious, previous, current, hundredDegree));
    hundredDegree++;
  }

  // назначаем первую букву первого слова (первого эл-та массива) заглавной
  textInteger[0] = textInteger[0].slice(0, 1).toUpperCase() + textInteger[0].slice(1, textInteger[0].length);

  // возвращаем результат соединения элементов массива в строку через пробел, валюту и копейки
  return textInteger.join(" ") + " " + textCurrency + " " + pennies(fraction);
}

console.log(numToText([1,2,3,,,,,5,".",9]))